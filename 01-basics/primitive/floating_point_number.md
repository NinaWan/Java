# Table of Content

* 一、计算机存储单位
* 二、原码、反码、补码、移码
* 三、计算机中小数的存储
    1. 科学计数法
    2. 小数的进制转换
    3. 定点数
    4. 浮点数
        * 浮点数的组成
        * 规格化
        * IEEE 754标准
        * 浮点数的表示范围

# 一、计算机存储单位

## 1. bit 比特/位

Stands for binary digit. 数据存储的`最小`单位。

## 2. byte 字节

数据存储的`基本`单位。1 byte = 8 bits.

# 二、原码、反码、补码、移码

数据在计算机中是以二进制的形式存储的。

> 计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，
> 而数值位，三种表示方法各不相同。在计算机系统中，数值一律用补码来表示和存储。
> 原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。
>
> <p align="right"> - 百度百科</p>

## 机器数和真值

### 机器数

数据在计算机中的二进制表示被称为机器数。机器数的最高位为符号位，0代表正数，1代表负数。

以8位为例：

* 5的机器数为`0000 0101`
* -5的机器数为`1000 0101`

### 机器数的真值

带符号位的机器数对应的真正的数值，就叫做机器数的真值。

以8位为例：

* 机器数`0000 0101`的真值为`+000 0101`，即5
* 机器数`1000 0101`的真值为`-000 0101`，即-5

## 原码

原码即为数据的原始二进制形式。

以8位为例，5的原码为`0000 0101`。

## 反码

反码通常用来作为原码与补码之间转换的过渡码。

### 原码求反码

* 原码为正数时，反码与原码相同；
* 原码为负数时，符号位不变，其他各位取反，得到的就是反码；
* 在反码中，整数0和小数0各有两种表现形式。`+0`与`-0`不一样。以8位为例：
    * 整数`+0`：原码为0,0000000，反码为0,0000000
    * 整数`-0`：原码为1,0000000，反码为1,1111111
    * 小数`+0`：原码为0.0000000，反码为0.0000000
    * 小数`-0`：原码为1.0000000，反码为1.1111111

## 补码

#### 原码求补码

* 原码为正数或零时，补码与原码相同；
* 原码为负数时，补码是在**反码**的基础上加1。

### 补码求原码

* 原码符号位为0，表示正数或零，原码同补码相同；
* 原码符号位为1，表示负数，则原码为补码的补码。以8位为例：
    * 补码为`1111 1000`，则原码为`1000 1000`

## 移码

移码是在补码的基础上将符号位取反。移码只能用于表示整数。

# 三、计算机中小数的存储

## 1. 科学计数法

科学计数法是一种计数的方法，将一个数字表示为a*10<sup>b</sup>的形式，也可记作aEb。其中a为整数，且$1\leq\vert a \vert\leq
10$，b为整数。

#### 科学计数法的好处

当我们需要表示一个较大或较小且位数较多的数字时，利用科学计数法可以节省空间和时间。

## 2. 小数的进制转换

### 2.1 二进制转十进制

与整数的二进制转十进制类似，不同的是从左到右依次乘以2的负数次幂。

#### 转换公式

$N_{(D)} = a\times 2^{-1} + b\times 2^{-2} + c\times 2^{-3} + ...$

由转换公式可知，在小数的二进制形式右侧添加零并不会影响小数本身的值，所以小数的二进制补零是在右侧，这与整数是不同的。

#### 举例：11010

$$
\begin{aligned}
十进制小数 &= 1\times2^{-1}+1\times2^{-2}+0\times2^{-3}+1\times2^{-4}+0\times2^{-5} \hspace{100cm}\\
&=0.5+0.25+0+0.0625+0 \\
&= 0.8125
\end{aligned}

$$

### 2.2 十进制转二进制

十进制小数转二进制，主要是利用小数部分乘以2，`顺序`取整数部分，直至小数部分为0。

#### 举例：0.125

1. 0.125*2 = 0.25，整数部分为0
2. 0.25*2 = 0.5，整数部分为0
3. 0.5*2 = 1.0，整数部分为1，同时小数部分为0，过程终止。

所以，0.125的二进制表示为001。

现实中，有些十进制小数，在转换过程中永远无法达到小数部分为0，例如0.4，这时候我们只需要计算到我们所需要的精度即可停止，得到的是目标小数的近似值。所以用二进制表示小数是可能有误差的，它并不一定与原小数完全相等。

## 3. 定点数

二进制表示中，固定小数点的位置，之前的位数用来表示整数部分，之后的位数用来表示小数部分，两部分合起来表示整个十进制小数。

例如，一个字节8位，约定前5位用来表示整数部分，后3位用来表示小数部分，则：

$1.25_{(D)} = 00001\,010_{(B)}$

**特别地，**

定点小数：小数点固定在第一位后面

定点整数：小数点固定在最后一位后面

### 定点数的局限性

因为小数点的位置是固定的，所以用定点数表示小数时整数部分的范围和小数部分的精度是固定有限的。

1. 如果小数点的位置越靠左，整数部分表示的范围越小；
2. 如果小数点的位置越靠右，小数部分表示的精度越小。

所以，通常用定点数形式来存储整数，而对于高精度的小数，需要用浮点数形式来存储。

## 4. 浮点数

为了解决定点数存储数据时所存在的问题，使用相同的位数存储更大的范围，通常使用浮点数来表示小数。

### 浮点数的组成

一个十进制数通过科学计数法可以写成一个小数乘以10的n次方的形式，同样的，一个二进制数可以写成一个二进制小数乘以2的n次方的形式。

**浮点数的组成部分：** `阶码(Exponent) + 尾数(Mantissa)`

**浮点数的真值：** $N = m \times b^e$，其中b为基数，m为尾数，e为阶码。

> 在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。
> m（即尾数）是形如±d.ddd...ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1)。
> 如果m的第一位是非0整数，m称作规格化的。
> 有一些描述使用一个单独的符号位(s 代表+或者-)来表示正负，这样m必须是正的。e是指数。
>
> <p align="right">- 百度百科</p>

简单来说，在二进制系统中，尾数指明一个二进制小数，而阶码则指明这个小数的小数点应该向左或是向右移动几位才是存储的真正的数值。

#### 阶码

阶码是通常用补码或者移码表示的定点整数。

**阶码的组成部分：** `阶符 + 阶码的数值部分`

**阶符：** 表示小数点移动的方向。阶符为正，表示尾数部分数值的小数点要右移；阶符为负，表示尾数部分数值的小数点要左移。

**阶码的数值部分：** 表示尾数部分数值的小数点要移动的位数。

因此，阶码反映的是浮点数的表示范围及小数点的实际位置。

#### 尾数

尾数是通常用原码或者补码表示的定点小数。

**尾数的组成部分：** `数符 + 尾数的数值部分`

**数符：** 决定正负，数符为0则表示正数，为1则表示负数，数符也直接决定整个浮点数的正负。

**尾数的数值部分：** 位数n反映浮点数的精度

#### 已知阶码和尾数求真值

### 规格化

浮点数的规格化：规定尾数的数值部分的最高位必须是一个有效值(即非零)。

* 左规：将尾数数值部分小数点左移一位，阶码减一
* 右规：将尾数数值部分小数点右移一位，阶码加一

#### 规格化浮点数的特点

### IEEE 754标准

尾数用原码表示，隐藏最高位1，实际表示的是1.M

阶码用移码表示，偏置值为2<sup>n-1</sup>-1

### 浮点数的表示范围（Java）

#### float

取值范围：

* 写法一：-3.4028235E38 ~ 3.4028235E38
* 写法二：-3.40E38 ~ 3.40E38
* 写法三：-2<sup>128</sup> ~ 2<sup>128</sup>
* 写法四：-(2-2<sup>-23</sup>)·2<sup>127</sup> ~ (2-2<sup>-23</sup>)·2<sup>127</sup> (i.e. Float类里最大值注释中的写法)

MAX_VALUE：

* 写法一：3.4028235E38
* 写法二：3.40E38
* 写法三：3.4028235$\times$10<sup>38</sup>
* 写法四：2<sup>128</sup>
* 写法五：(2-2<sup>-23</sup>)·2<sup>127</sup>

非规格化非零最小正值(MIN_VALUE)： 最小正非零值常量，是非规格化浮点数所能表示的最小值。值为 1.4E-45 的常量

* 写法一：1.4E-45
* 写法二：1.4$\times$10<sup>-45</sup>
* 写法三：2<sup>-149</sup>

规格化非零最小正值(MIN_NORMAL)： 最小正标准值常量，是规格化浮点数所能表示的最小值，即 2^-126。

* 写法一：1.17549435E-38
* 写法二：1.17549435$\times$10<sup>-38</sup>
* 写法三：2<sup>-126</sup>

#### double

取值范围：

* 写法一：-1.7976931348623157E308 ~ 1.7976931348623157E308
* 写法二：-1.79E308 ~ +1.79E308
* 写法三：-2<sup>1024</sup> ~ +2<sup>1024</sup>
* 写法四：-(2-2<sup>-52</sup>)·2<sup>1023</sup> ~ (2-2<sup>-52</sup>)·2<sup>1023</sup> (i.e.
  Double类里最大值注释中的写法)

MAX_VALUE：

* 写法一：1.7976931348623157E308
* 写法二：1.79E308
* 写法三：1.7976931348623157$\times$10<sup>308</sup>
* 写法四：2<sup>1024</sup>
* 写法五：(2-2<sup>-52</sup>)·2<sup>1023</sup>

非规格化非零最小正值(MIN_VALUE)： 最小正非零值常量，是非规格化浮点数所能表示的最小值。值为 4.9E-324 的常量

* 写法一：4.9E-324
* 写法二：4.9$times$<sup>-324</sup>
* 写法三：2<sup>-1074</sup>

规格化非零最小正值(MIN_NORMAL)： 最小正标准值常量，是规格化浮点数所能表示的最小值，即 2^-1022。

* 写法一：2.2250738585072014E-308
* 写法二：2.2250738585072014$\times$<sup>-308</sup>
* 写法三：2<sup>-1022</sup>

# Refs

1. [百度百科 - 反码](https://baike.baidu.com/item/%E5%8F%8D%E7%A0%81/769985)
2. [百度百科 - 补码](https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613)
3. [CSDN - 计组——浮点数的表示和运算](https://blog.csdn.net/vavid317/article/details/119781487)
4. [百度百科 - 浮点数](https://baike.baidu.com/item/%E6%B5%AE%E7%82%B9%E6%95%B0/6162520)

# Readings

1. [微信 - 理解进制转换的原理](https://mp.weixin.qq.com/s/BDR31lJ8Z2JNNPANuUJ-7g) (2019)
2. [知乎 - 单精度与双精度是什么意思，有什么区别？](https://www.zhihu.com/question/26022206) (2014)
3. [知乎 - 什么是定点数？](https://zhuanlan.zhihu.com/p/338588296) (2021)
4. [博客园 - 原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html) (2011)
5. [简书 - 负数取模怎么算](https://www.jianshu.com/p/452c1a5acd31) (2014)
6. [百度百科 - 移码](https://baike.baidu.com/item/%E7%A7%BB%E7%A0%81/10165919)
7. [简书 - 移码](https://www.jianshu.com/p/411cab22a71e)
