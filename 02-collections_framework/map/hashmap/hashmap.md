# HashMap

## 哈希冲突解决方法

采用链地址法解决哈希冲突

## JDK1.7 VS JDK1.8

### 底层数据结构

**JDK1.7**

数组+链表

**JDK1.8**

数组+链表/红黑树，当链表长度大于等于7时转化成红黑树。

### 链表插入方式

**JDK1.7**

表头插入

**JDK1.8**

表尾插入

### 扩容机制

**JDK1.7**

* 扩容时，对于每个entry，会重新计算哈希值和索引位置；
* 转移数据时，从头到尾遍历table中每个链表，并采用表头插入法插入到重新计算后的索引位置，所以扩容后会导致原本链表中元素的顺序发生变化，进而在并发场景下导致链表成环引发死循环问题。

**JDK1.8**

* 扩容时，对于每个entry，不会重新计算哈希值，但会重新计算索引位置：
    * 如果只有一个entry，使用新的数组长度计算：hash&(n-1);
    * 如果有多个一个entry且是链表，使用旧的数组长度的计算结果(hash&oldCap)，将entries分发到新数组中两个不同的位置：
        * if hash&oldCap==0，将该entry插入到newTab[i]的链表尾部; // 原数组位置
        * if hash&oldCap==1，将该entry插入到newTab[i+oldCap]的链表尾部; // 原数组位置后移oldCap
* 转移数据时，对于oldTab中的每个链表进行由头至尾的遍历，并采用表尾插入法插入到重新计算后的索引位置，所以原本链表中元素的顺序不会发生变化，所以不会导致死循环问题。