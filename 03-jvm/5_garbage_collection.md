# 垃圾回收 Garbage Collection

## 概述

垃圾回收发生的位置：堆和方法区

## 对象回收条件

### 引用

1. 强引用

   只要强引用存在，对象就不会被回收。通过new关键字实现的引用就是强引用。

2. 软引用

   当内存不足时，会对软引用关联的对象进行回收。通过SoftReference类来实现。

3. 弱引用

   当下次GC时，弱引用关联的对象会被回收。通过WeakReference类来实现。

4. 虚引用

   虚引用类似于无引用，所关联的对象随时会被回收，且不能通过引用来获得对象实例。通过PhantomReference类和ReferenceQueue类来实现。使用虚引用的目的是为了能在对象被回收时收到一个系统通知。

### 如何判断对象是否可回收

#### 引用计数法

#### 可达性分析

GC Roots:

* 全局性引用
    * 方法区中**类静态属性**引用的对象
    * 方法区中**常量**引用的对象
* 执行上下文
    * 虚拟机栈中**局部变量表**中引用的对象
    * 本地方法栈中**JNI**中引用的对象
* 已启动且未停止的Java线程

## 垃圾收集算法

### 标记-清除算法

* 标记阶段

  检查每个对象，标记对象是否可回收。

* 清除阶段

  回收那些被标记为可回收的对象，释放对应的内存空间，将释放后的空闲分块加入到空闲链表中，并合并连续的空闲分块。

#### 缺点

* 效率不稳定

  当有大量对象且存活率低的时候，需要进行大量的标记和清除工作，导致效率低下。

* 内存碎片化

### 标记-复制算法

将内存空间分为大小相同的两块，每次只使用其中的一块。

* 标记阶段

  检查每个对象，标记对象是否可回收。

* 复制阶段

  将存活的对象复制到另一块内存空间中，一次性清理掉当前使用过的这块内存空间。

#### 优点

解决了标记-清除算法在处理大量可回收对象时效率低的问题。

#### 缺点

每次可使用的内存空间只有原来的一半。

### 标记-整理算法

* 标记阶段

  检查每个对象，标记对象是否可回收。

* 整理阶段

  将存活的对象移动到内存空间的一端，直接清理掉另一端的内存空间。

#### 优点

不会产生内存碎片。

#### 缺点

需要移动存活的对象，效率不如标记-复制算法。

### 分代收集算法

将堆空间划分为不同的区域，根据对象存活的次数，将其分配到对应的区域里，根据每个区域里对象的特点，采用适应的垃圾收集算法。

一般分为新生代和老年代。新生代中的大部分对象在垃圾回收过程中会被回收，而达到一定存活次数的对象会被转移到老年代中，所以新生代可以采用标记-复制算法。老年代中的对象存活率比较高，需要保证更多的内存空间，所以老年代会采用标记-清除算法或者标记-整理算法。

## 垃圾收集器

### 新生代收集器

#### Serial

单线程，回收过程中其他工作线程都必须暂停。

基于标记-复制算法。

#### ParNew

Serial的多线程并行版本。

基于标记-复制算法。

#### Parallel Scavenge

与ParNew类似，不过更侧重于关注对吞吐量的控制。这里的吞吐量指的是CPU用于运行用户程序的时间占比。

可以通过-XX:MaxGCPauseMillis参数来设置垃圾回收的最大停顿时间和-XX:GCTimeRatio参数来直接设置吞吐量的大小。

基于标记-复制算法。

### 老年代收集器

#### Serial Old

Serial的老年代版本。

基于标记-整理算法。

#### Parallel Old

Parallel Scavenge的老年代版本。

基于标记-整理算法。

#### CMS (Concurrent Mask Sweep)

多线程，用户线程和GC线程可以同时工作。以获得最短停顿时间为目标。

基于标记-清除算法。

过程：

1. 初始标记 Initial Mark (STW)

   标记与GC Roots直接关联的对象，需要暂停正在执行的任务，速度快。

2. 并发标记 Concurrent Mark

   在初始标记的基础上，继续向下追溯标记，应用程序线程和GC线程可以并发执行。

3. 并发预清理 Concurrent Pre-cleaning

   查找在并发标记阶段新进入老年代的对象，减少下一个阶段的工作量。

4. 重新标记 Remark (STW)

   重新从GC Roots开始向下追溯标记，目的是为了处理在并发标记阶段因为应用程序的运行而导致的对象关联变化，需要暂停正在执行的任务。

5. 并发清理 Concurrent Sweeping

   清理垃圾对象。

6. 并发重置 Concurrent Reset

   重置收集器的数据。

### G1 (Garbage First)

上述的垃圾收集器都只能对新生代**或者**年老代进行垃圾回收，而G1收集器被设计为可以对新生代和年老代一起进行垃圾回收。

G1收集器将整个堆空间划分成一个个大小相等的独立的区域(Region)，可以对每个Region进行独立的垃圾回收。

通过记录每个Region垃圾回收的时间和获取的空间的大小，维护一个优先列表，根据允许的垃圾回收时间，选择空间回报率最优的Region进行回收。

每个Region都有一个Remembered Set，用来记录该Region里的对象所引用的对象所在的Region。

过程：

1. 初始标记
2. 并发标记
3. 最终标记

   在并发标记阶段，JVM会将由于用户程序运行而导致的对象变化记录到每个线程的Remembered Set Logs里，在最终标记阶段，会将这些Remembered
   Set Logs合并到对应的Region的Remembered Set里。

4. 筛选回收

   根据每个Region的回收回报和用户所期望的GC停顿时间来制定回收计划并进行垃圾回收。

### ZGC

### Epsilon

## 内存分配与回收策略

### 分配策略

1. 对象优先在Eden分配

   一般情况下，新对象在新生代Eden上进行分配，当新生代空间不足时，会触发Minor GC。

2. 大对象直接进入老年代

   大对象指的是需要大量连续内存空间的对象。
   -XX:PretenureSizeThreshold，大小大于此值的对象直接在老年代进行分配。

3. 长期存活的对象进入老年代

   -XX:MaxTenuringThreshold，新生代中年龄大于此值的对象将进入老年代。
   新生代每经过一次Minor GC，存活下来的对象的年龄将加一。

4. 动态对象年龄判定

   新生代的对象也不是一定非要达到设定的年龄阈值才能进入老年代。当Survivor区中某一年龄的对象大小的总和超过了Survivor区大小的一半，则会将年龄大于等于该年龄的对象移动到老年代中。

5. 空间分配担保

   在进行Minor GC之前，虚拟机会检查老年代中最大的可用的连续内存空间是否大于新生代中所有对象的总大小：
    * 如果满足，则Minor GC是安全的；
    * 如果不满足，会再检查HandlePromotionFailure的值：
        * 如果不允许担保失败，则需要进行一次Full GC；
        * 如果允许担保失败，则检查老年代中最大的可用的连续内存空间是否大于以往晋升到老年代的对象的平均大小：
            * 如果满足，则尝试进行一次Minor GC；
            * 如果不满足，则需要进行一次Full GC。

### 回收策略

#### Minor GC

对新生代进行垃圾回收，比较频繁，用时较少。

#### Major GC

对老年代进行垃圾回收。

#### Full GC

对整个堆空间进行垃圾回收。