# 运行时数据区域

JVM在运行过程中会将所管理的内存划分成不同的数据区域，用于存储和管理程序运行所需要的不同的数据。

#### Java内存区域

Java内存区域包含以下五部分：

* 程序计数器 PC Register
* Java虚拟机栈 JVM Stack
* 本地方法栈 Native Method Stack
* 堆 Heap
* 方法区 Method Area

根据是否是线程私有，又可以分为：

* **线程私有**：程序计数器、Java虚拟机栈、本地方法栈

* **线程共享**：堆、方法区

## 1. 程序计数器 PC Register

一块较小的内存区域，是程序执行的行数指示器。如果当前执行的是Java程序，则指示的是执行的字节码的行数；如果当前执行的是本地方法，则为空。

## 2. Java虚拟机栈 JVM Stack

Java虚拟机栈是对线程方法调用的表示。当一个方法被调用的时候，会创建一个栈帧(Stack Frame)，压入栈中。方法的调用过程对应着栈帧入栈出栈的过程。

栈帧中包含被调用方法的相关信息，包括局部变量表、操作数、方法返回地址等。

## 3. 本地方法栈 Native Method Stack

本地方法栈与Java虚拟机栈类似，不过表示的是本地方法的调用。

## 4. 堆 Heap

堆是Java虚拟机内存区域中重要的组成部分。最主要的作用就是存放程序运行中所生成的对象，也是垃圾回收的主要区域。

根据垃圾回收的逻辑，JVM堆又可以分为年轻代(young generation)和老年代(old generation)两部分，大小比例为1:2。

年轻代又包含Eden~~(新生代)~~、Survivor From 和 Survivor To三部分，大小比例为8:1:1，可通过参数进行调整。

新生成的对象会首先进入Eden区，如果Eden区没有足够的空闲空间进行分配，则会进行一次Minor GC，Minor GC之后，Eden和Survivor
From内存活下来的对象会被复制到Survivor To区，Eden区和Survivor
From区会被清空，然后From区和To区会互换，也就是说下一次GC时，当下的From区是To区，而当下的To区是From区，因此可以确保每次GC时To区总是空的。

经过N轮GC仍旧存活的对象会进入老年代，N可以通过参数进行设置。
另外，如果对象较大，Eden区无法容纳，则会直接进入老年代，如果老年代没有足够的空间，则会触发一次Major
GC，如果仍旧无法容纳，则会抛出OutOfMemory异常。

## 5. 方法区 Method Area

方法区是逻辑上的概念，永久代和元空间是其不同的实现方式。方法区主要存放的是类型信息。

### 5.1 Permanent Space 永久代

JDK8之前，~~(HotSpot的实现方式？)~~方法区的实现方式是永久代。

### 5.2 Meta Space 元空间

JDK8以及之后的版本，永久代被彻底移除，取而代之的是元空间。与永久代不同，元空间不属于JVM管理的内存区域，而是属于直接内存(
native memory)，所以元空间的大小并不受JVM内存大小的限制。

### 5.3 永久代到元空间的演化

JDK7版本中，字符串常量池和静态变量从永久代移到JVM堆中。

JDK8版本中，将永久代中剩余的部分转移到元空间中，而字符串常量池和静态变量则保留在JVM堆中，永久代被彻底移除。
